{"code":"import * as tslib_1 from \"tslib\";\r\nimport N3 from 'n3';\r\nimport { NS_RDF, NS_DC, NS_UI, NS_LAYOUT, IRI_XsdString } from '../constants';\r\nimport { ListObject } from './list-object';\r\nvar ShexToUiForm = /** @class */ (function () {\r\n    function ShexToUiForm(schema) {\r\n        this.termFactory = N3.DataFactory;\r\n        this.graph = new N3.Store();\r\n        this.meta = { prefixes: schema._prefixes, base: window.location.href };\r\n        this.iriRdftype = NS_RDF + \"type\";\r\n        this.iriDctitle = NS_DC + \"title\";\r\n        this.iriUitype = this.iriRdftype;\r\n        this.schema = schema;\r\n    }\r\n    /**\r\n     * Convert SheEx to Form Model\r\n     */\r\n    ShexToUiForm.prototype.convert = function () {\r\n        var _a = this, schema = _a.schema, _b = _a.termFactory, namedNode = _b.namedNode, blankNode = _b.blankNode, literal = _b.literal, graph = _b.graph;\r\n        var IRI_this = '#';\r\n        var rootFormTerm = namedNode(IRI_this + \"formRoot\");\r\n        var start = 'start' in this.schema ? this.derefShapeExpression(schema.start) : schema.shapes[0];\r\n        this.walkShape(start, rootFormTerm, this.localName(start.id), namedNode, literal, blankNode);\r\n        var writer = new N3.Writer({\r\n            prefixes: { '': IRI_this, ui: NS_UI, dc: NS_DC },\r\n            listHeads: graph.sequesterLists()\r\n        });\r\n        writer.addQuads(graph.getQuads());\r\n        var formModel;\r\n        writer.end(function (error, result) { return formModel = result; });\r\n        return formModel;\r\n    };\r\n    ShexToUiForm.prototype.findTitle = function (shexpr) {\r\n        var _this = this;\r\n        return (shexpr.annotations || []).find(function (a) { return a.predicate === _this.iriDctitle; });\r\n    };\r\n    ShexToUiForm.prototype.localName = function (iri) {\r\n        var meta = this.meta;\r\n        if (iri.startsWith('_:')) {\r\n            return iri;\r\n        }\r\n        var prefix = Object.keys(meta.prefixes).find(function (p) { return iri.startsWith(meta.prefixes[p]); });\r\n        if (prefix) {\r\n            return prefix + (\":\" + iri.substr(meta[prefix].length));\r\n        }\r\n        return \"<\" + (iri.startsWith(meta.base) ? iri.substr(meta.base.length) : iri) + \">\";\r\n    };\r\n    ShexToUiForm.prototype.derefShapeExpression = function (shapeExpr) {\r\n        if (typeof shapeExpr !== 'string') {\r\n            return shapeExpr;\r\n        }\r\n        var ret = this.findShapeExpression(shapeExpr);\r\n        if (!ret) {\r\n            throw Error(\"unable to find shape expression \\\"\" + shapeExpr + \"\\\" in \\n            \" + this.schema.shapes.map(function (se) { return se.id; }).join('\\n'));\r\n        }\r\n        return ret;\r\n    };\r\n    /**\r\n     * Find shape expression with given name in schema.\r\n     * returns: corresponding shape expression or undefined\r\n     */\r\n    ShexToUiForm.prototype.findShapeExpression = function (goal) {\r\n        return this.schema.shapes.find(function (se) { return se.id === goal; });\r\n    };\r\n    ShexToUiForm.prototype.walkShape = function (shape, formTerm, path, namedNode, literal, blankNode) {\r\n        var _this = this;\r\n        try {\r\n            var graph_1 = this.graph;\r\n            var sanitizedPath_1 = path.replace(/[^A-Za-z_-]/g, '_');\r\n            graph_1.addQuad(formTerm, namedNode(NS_RDF + \"type\"), namedNode(NS_UI + \"Form\"));\r\n            var label = this.findTitle(shape);\r\n            if (label)\r\n                graph_1.addQuad(formTerm, namedNode(this.iriDctitle), literal(label.object.value));\r\n            var currentShape = shape;\r\n            if (!(\"expression\" in shape) || shape.expression.type !== \"EachOf\") {\r\n                currentShape = tslib_1.__assign({}, currentShape, { expression: { expressions: [currentShape.expression] } });\r\n            }\r\n            // The UI vocabulary accepts only lists of atoms.\r\n            var parts_1 = new ListObject(formTerm, namedNode(NS_UI + \"parts\"), graph_1, this.termFactory);\r\n            if (currentShape && currentShape.expression && currentShape.expression.expressions) {\r\n                currentShape.expression.expressions.forEach(function (te, i) {\r\n                    var tePath = path + \"/[\" + i + \"]\";\r\n                    if (te.type !== 'TripleConstraint') {\r\n                        throw Error(\"expected \" + tePath + \" of type TripleConstraint, got: \" + JSON.stringify(te));\r\n                    }\r\n                    var fieldTerm = 'id' in te ? _this.jsonLdtoRdf(te.id) : blankNode(sanitizedPath_1 + \"_parts_\" + i + \"_field\");\r\n                    var fieldType = te.valueExpr && te.valueExpr.values ? 'Classifier' : 'SingleLineTextField';\r\n                    var needFieldType = namedNode(NS_UI + fieldType);\r\n                    // copy annotations\r\n                    if (\"annotations\" in te)\r\n                        te.annotations.forEach(function (a) {\r\n                            if (a.predicate === NS_LAYOUT + \"ref\") {\r\n                                return;\r\n                            }\r\n                            if (a.predicate === _this.iriRdftype) {\r\n                                needFieldType = null;\r\n                            }\r\n                            if (a.predicate === NS_UI + \"contents\") {\r\n                                // ui:contents get their own item in the list\r\n                                var commentTerm = \"id\" in te\r\n                                    ? _this.jsonLdtoRdf(te.id + \"Comment\") // !! could collide, but easy to debug\r\n                                    : blankNode(sanitizedPath_1 + \"_parts_\" + i + \"_comment\");\r\n                                graph_1.addQuad(commentTerm, namedNode(_this.iriUitype), namedNode(NS_UI + \"Comment\"));\r\n                                graph_1.addQuad(commentTerm, namedNode(NS_UI + \"contents\"), _this.jsonLdtoRdf(a.object));\r\n                                // add the parts list entry for comment\r\n                                parts_1.add(commentTerm, sanitizedPath_1 + \"_parts_\" + i + \"_comment\");\r\n                            }\r\n                            else if (a.predicate.includes('label')) {\r\n                                graph_1.addQuad(fieldTerm, namedNode(NS_UI + \"label\"), _this.jsonLdtoRdf(a.object));\r\n                            }\r\n                            else {\r\n                                graph_1.addQuad(fieldTerm, _this.jsonLdtoRdf(a.predicate), _this.jsonLdtoRdf(a.object));\r\n                            }\r\n                        });\r\n                    // add the parts list entry for new field\r\n                    parts_1.add(fieldTerm, sanitizedPath_1 + \"_parts_\" + i);\r\n                    // add property arc\r\n                    graph_1.addQuad(fieldTerm, namedNode(NS_UI + \"property\"), _this.jsonLdtoRdf(te.predicate));\r\n                    var valueExpr = typeof te.valueExpr === 'string'\r\n                        ? _this.derefShapeExpression(te.valueExpr)\r\n                        : te.valueExpr;\r\n                    // add what we can guess from the value expression\r\n                    if (valueExpr.type === 'Shape') {\r\n                        needFieldType = null;\r\n                        var groupId = blankNode(sanitizedPath_1 + \"_parts_\" + i + \"_group\");\r\n                        graph_1.addQuad(fieldTerm, _this.iriRdftype, namedNode(NS_UI + \"Multiple\"));\r\n                        graph_1.addQuad(fieldTerm, namedNode(NS_UI + \"part\"), groupId);\r\n                        _this.walkShape(valueExpr, groupId, path + \"/@\" + _this.localName(te.valueExpr), namedNode, literal, blankNode);\r\n                    }\r\n                    else if (valueExpr.type === 'NodeConstraint') {\r\n                        var nc = valueExpr;\r\n                        if ('maxlength' in nc) {\r\n                            graph_1.addQuad(fieldTerm, namedNode(NS_UI + \"maxLength\"), _this.jsonLdtoRdf({ value: nc.maxlength }));\r\n                        }\r\n                        if ('pattern' in nc) {\r\n                            graph_1.addQuad(fieldTerm, namedNode(NS_UI + \"pattern\"), _this.jsonLdtoRdf({ value: nc.pattern }));\r\n                        }\r\n                    }\r\n                    else {\r\n                        throw Error(\"Unsupported value expression on \" + tePath + \": \" + JSON.stringify(valueExpr));\r\n                    }\r\n                    // if there's no type, assume ui:SingleLineTextField\r\n                    if (needFieldType) {\r\n                        graph_1.addQuad(fieldTerm, namedNode(_this.iriRdftype), needFieldType);\r\n                    }\r\n                });\r\n            }\r\n            parts_1.end();\r\n        }\r\n        catch (error) {\r\n            throw Error(error);\r\n        }\r\n    };\r\n    ShexToUiForm.prototype.jsonLdtoRdf = function (ld) {\r\n        var _a = this.termFactory, namedNode = _a.namedNode, literal = _a.literal, blankNode = _a.blankNode;\r\n        if (typeof ld === 'object' && 'value' in ld) {\r\n            var dtOrLang = ld.language || (ld.datatype && ld.datatype !== IRI_XsdString)\r\n                ? ld.language : namedNode(ld.datatype);\r\n            return literal(ld.value, dtOrLang);\r\n        }\r\n        else if (ld.startsWith('_:')) {\r\n            return blankNode(ld.substr(2));\r\n        }\r\n        else {\r\n            return namedNode(ld);\r\n        }\r\n    };\r\n    return ShexToUiForm;\r\n}());\r\nexport { ShexToUiForm };\r\n//# sourceMappingURL=shex-ui.js.map","references":["/Users/jairocampos/Public/janeiro/solid-sdk-forms/node_modules/@types/n3/index.d.ts","/Users/jairocampos/Public/janeiro/solid-sdk-forms/src/constants/index.ts","/Users/jairocampos/Public/janeiro/solid-sdk-forms/src/classes/list-object.ts"],"map":"{\"version\":3,\"file\":\"shex-ui.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../src/classes/shex-ui.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/Users/jairocampos/Public/janeiro/solid-sdk-forms/dist/types/classes/shex-ui.d.ts","writeByteOrderMark":false,"text":"interface Meta {\r\n    [key: string]: any;\r\n    prefixes: any;\r\n    base: string;\r\n}\r\nexport declare class ShexToUiForm {\r\n    termFactory: any;\r\n    meta: Meta;\r\n    schema: any;\r\n    graph: any;\r\n    iriRdftype: string;\r\n    iriDctitle: string;\r\n    iriUitype: string;\r\n    constructor(schema: any);\r\n    /**\r\n     * Convert SheEx to Form Model\r\n     */\r\n    convert(): undefined;\r\n    findTitle(shexpr: any): any;\r\n    localName(iri: string): string;\r\n    derefShapeExpression(shapeExpr: any): any;\r\n    /**\r\n     * Find shape expression with given name in schema.\r\n     * returns: corresponding shape expression or undefined\r\n     */\r\n    findShapeExpression(goal: string): any;\r\n    walkShape(shape: any, formTerm: any, path: string, namedNode: any, literal: any, blankNode: any): void;\r\n    jsonLdtoRdf(ld: any): any;\r\n}\r\nexport {};\r\n"}}
