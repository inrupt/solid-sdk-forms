export declare const ShExRSchema = "PREFIX sx: <http://www.w3.org/ns/shex#>\nPREFIX xsd: <http://www.w3.org/2001/XMLSchema#>\nPREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\nBASE <http://www.w3.org/ns/shex#>\nstart=@<Schema>\n\n<Schema> CLOSED {\n  a [sx:Schema] ;\n  sx:imports @<IriList1Plus>? ;\n  sx:startActs @<SemActList1Plus>? ;\n  sx:start @<shapeExpr>?;\n  sx:shapes @<shapeExpr>*\n}\n\n<shapeExpr> @<ShapeOr> OR @<ShapeAnd> OR @<ShapeNot> OR @<NodeConstraint> OR @<Shape> OR @<ShapeExternal>\n\n<ShapeOr> CLOSED {\n  a [sx:ShapeOr] ;\n  sx:shapeExprs @<shapeExprList2Plus>\n}\n\n<ShapeAnd> CLOSED {\n  a [sx:ShapeAnd] ;\n  sx:shapeExprs @<shapeExprList2Plus>\n}\n\n<ShapeNot> CLOSED {\n  a [sx:ShapeNot] ;\n  sx:shapeExpr @<shapeExpr>\n}\n\n<NodeConstraint> CLOSED {\n  a [sx:NodeConstraint] ;\n  sx:nodeKind [sx:iri sx:bnode sx:literal sx:nonliteral]?;\n  sx:datatype IRI ? ;\n  &<xsFacets>  ;\n  sx:values @<valueSetValueList1Plus>?\n}\n\n<Shape> CLOSED {\n  a [sx:Shape] ;\n  sx:closed [true false]? ;\n  sx:extra IRI* ;\n  sx:expression @<tripleExpression>? ;\n  sx:semActs @<SemActList1Plus>? ;\n  sx:annotation @<AnnotationList1Plus>? ;\n}\n\n<ShapeExternal> CLOSED {\n  a [sx:ShapeExternal] ;\n}\n\n<SemAct> CLOSED {\n  a [sx:SemAct] ;\n  sx:name IRI ;\n  sx:code xsd:string?\n}\n\n<Annotation> CLOSED {\n  a [sx:Annotation] ;\n  sx:predicate IRI ;\n  sx:object @<objectValue>\n}\n\n# <xsFacet> @<stringFacet> OR @<numericFacet>\n<facet_holder> { # hold labeled productions\n  $<xsFacets> ( &<stringFacet> | &<numericFacet> )* ;\n  $<stringFacet> (\n      sx:length xsd:integer\n    | sx:minlength xsd:integer\n    | sx:maxlength xsd:integer\n    | sx:pattern xsd:string ; sx:flags xsd:string?\n  );\n  $<numericFacet> (\n      sx:mininclusive   @<numericLiteral>\n    | sx:minexclusive   @<numericLiteral>\n    | sx:maxinclusive   @<numericLiteral>\n    | sx:maxexclusive   @<numericLiteral>\n    | sx:totaldigits    xsd:integer\n    | sx:fractiondigits xsd:integer\n  )\n}\n<numericLiteral> xsd:integer OR xsd:decimal OR xsd:double\n\n<valueSetValue> @<objectValue> OR @<IriStem> OR @<IriStemRange>\n                               OR @<LiteralStem> OR @<LiteralStemRange>\n                OR @<Language> OR @<LanguageStem> OR @<LanguageStemRange>\n<objectValue> IRI OR LITERAL # rdf:langString breaks on Annotation.object\n<Language> CLOSED { a [sx:Language]; sx:languageTag xsd:string }\n<IriStem> CLOSED { a [sx:IriStem]; sx:stem xsd:string }\n<IriStemRange> CLOSED {\n  a [sx:IriStemRange];\n  sx:stem xsd:string OR @<Wildcard>;\n  sx:exclusion @<IriStemExclusionList1Plus>\n}\n<LiteralStem> CLOSED { a [sx:LiteralStem]; sx:stem xsd:string }\n<LiteralStemRange> CLOSED {\n  a [sx:LiteralStemRange];\n  sx:stem xsd:string OR @<Wildcard>;\n  sx:exclusion @<LiteralStemExclusionList1Plus>\n}\n<LanguageStem> CLOSED { a [sx:LanguageStem]; sx:stem xsd:string }\n<LanguageStemRange> CLOSED {\n  a [sx:LanguageStemRange];\n  sx:stem xsd:string OR @<Wildcard>;\n  sx:exclusion @<LanguageStemExclusionList1Plus>\n}\n<Wildcard> BNODE CLOSED {\n  a [sx:Wildcard]\n}\n\n<tripleExpression> @<TripleConstraint> OR @<OneOf> OR @<EachOf> OR CLOSED {  }\n\n<OneOf> CLOSED {\n  a [sx:OneOf] ;\n  sx:min xsd:integer? ;\n  sx:max xsd:integer? ;\n  sx:expressions @<tripleExpressionList2Plus> ;\n  sx:semActs @<SemActList1Plus>? ;\n  sx:annotation @<AnnotationList1Plus>?\n}\n\n<EachOf> CLOSED {\n  a [sx:EachOf] ;\n  sx:min xsd:integer? ;\n  sx:max xsd:integer? ;\n  sx:expressions @<tripleExpressionList2Plus> ;\n  sx:semActs @<SemActList1Plus>? ;\n  sx:annotation @<AnnotationList1Plus>?\n}\n\n<tripleExpressionList2Plus> CLOSED {\n  rdf:first @<tripleExpression> ;\n  rdf:rest @<tripleExpressionList1Plus>\n}\n<tripleExpressionList1Plus> CLOSED {\n  rdf:first @<tripleExpression> ;\n  rdf:rest  [rdf:nil] OR @<tripleExpressionList1Plus>\n}\n\n<TripleConstraint> CLOSED {\n  a [sx:TripleConstraint] ;\n  sx:inverse [true false]? ;\n  sx:negated [true false]? ;\n  sx:min xsd:integer? ;\n  sx:max xsd:integer? ;\n  sx:predicate IRI ;\n  sx:valueExpr @<shapeExpr>? ;\n  sx:semActs @<SemActList1Plus>? ;\n  sx:annotation @<AnnotationList1Plus>?\n}\n\n<IriList1Plus> CLOSED {\n  rdf:first IRI ;\n  rdf:rest  [rdf:nil] OR @<IriList1Plus>\n}\n\n<SemActList1Plus> CLOSED {\n  rdf:first @<SemAct> ;\n  rdf:rest  [rdf:nil] OR @<SemActList1Plus>\n}\n\n<shapeExprList2Plus> CLOSED {\n  rdf:first @<shapeExpr> ;\n  rdf:rest  @<shapeExprList1Plus>\n}\n<shapeExprList1Plus> CLOSED {\n  rdf:first @<shapeExpr> ;\n  rdf:rest  [rdf:nil] OR @<shapeExprList1Plus>\n}\n\n<valueSetValueList1Plus> CLOSED {\n  rdf:first @<valueSetValue> ;\n  rdf:rest  [rdf:nil] OR @<valueSetValueList1Plus>\n}\n\n<AnnotationList1Plus> CLOSED {\n  rdf:first @<Annotation> ;\n  rdf:rest  [rdf:nil] OR @<AnnotationList1Plus>\n}\n\n<IriStemExclusionList1Plus> CLOSED {\n  rdf:first IRI OR @<IriStem> ;\n  rdf:rest  [rdf:nil] OR @<IriStemExclusionList1Plus>\n}\n\n<LiteralStemExclusionList1Plus> CLOSED {\n  rdf:first xsd:string OR @<LiteralStem> ;\n  rdf:rest  [rdf:nil] OR @<LiteralStemExclusionList1Plus>\n}\n\n<LanguageStemExclusionList1Plus> CLOSED {\n  rdf:first xsd:string OR @<LanguageStem> ;\n  rdf:rest  [rdf:nil] OR @<LanguageStemExclusionList1Plus>\n}\n";
